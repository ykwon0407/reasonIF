import logging
import random
import re
import json
from fast_langdetect import detect, FastLangdetectError as DetectError
from .instruction_util import LANGUAGE_CODES, count_words

_LANGUAGES = LANGUAGE_CODES

# The number of words in the response.
NUM_WORDS_LOWER_DEFAULT = 1

# The options of ending keywords.
_ENDING_OPTIONS = ("THIS THOUGHT PROCESS WAS GENERATED BY AI",
                   "THIS REASONING WAS PRODUCED BY AI",
                   "THIS ANALYSIS WAS CREATED BY AI",
                   "THIS LOGIC WAS GENERATED THROUGH AI",
                   "THIS EXPLANATION IS AI-GENERATED",
                   "THIS ARGUMENT WAS CONSTRUCTED BY AI")

class Constraint:
    """An Constraint template."""

    def __init__(self, constraint_id=0):
        self.id = constraint_id

    def build_description(self, **kwargs):
        raise NotImplementedError("`build_description` not implemented.")

    def get_constraint_args(self):
        raise NotImplementedError("`get_constraint_args` not implemented.")

    def get_constraint_args_keys(self):
        raise NotImplementedError("`get_constraint_args_keys` not implemented.")

    def check_following(self, value):
        raise NotImplementedError("`check_following` not implemented.")

class ReasoningLanguageChecker(Constraint):
    """Check the language of the entire reasoning."""

    def build_description(self, *, language=None):
        self._language = language
        if self._language is None:
            self._language = random.choice(list(_LANGUAGES.keys()))
        
        self._description_pattern = (
            "When reasoning, respond only in {language} language, no other language is allowed."
        )
        return self._description_pattern.format(language=_LANGUAGES[self._language].capitalize())

    def get_constraint_args(self):
        """Returns the keyword args of `build_description`."""
        return {"language": self._language}

    def check_following(self, value):
        """Check if the language of the entire response follows the Constraint.

        Args:
          value: A string representing the response.

        Returns:
          True if the language of `value` follows Constraint; otherwise False.
        """
        assert isinstance(value, str)

        try:
            return detect(value, low_memory=False)['lang'] == self._language
        except DetectError as e:
            # Count as Constraint is followed.
            logging.error(
                "Unable to detect language for text %s due to %s", value, e
            )  # refex: disable=pytotw.037
            return True

class NumberOfWords(Constraint):
    """Checks the number of words."""

    def build_description(self, *, num_words=0):
        """Build the Constraint description.

        Args:
          num_words: An integer specifying the number of words contained in the
            response.

        Returns:
          A string representing the Constraint description.
        """

        self._num_words = num_words # default value is set to GPT-OSS-120B's 20-th percentile.
        self._description_pattern = "When reasoning, respond with less than {num_words} words."

        return self._description_pattern.format(
            num_words=self._num_words
        )

    def get_constraint_args(self):
        """Returns the keyword args of `build_description`."""
        return {"num_words": self._num_words}

    def get_constraint_args_keys(self):
        """Returns the args keys of `build_description`."""
        return ["num_words"]

    def check_following(self, value):
        """Checks if the response contains the expected number of words."""
        num_words = count_words(value)
        return num_words < self._num_words

class CapitalLettersEnglishChecker(Constraint):
    """Checks that the response is in english and is in all capital letters."""

    def build_description(self):
        """Build the Constraint description."""
        self._description_pattern = (
            "When reasoning, your response should be in English and in all capital letters."
        )
        return self._description_pattern

    def get_constraint_args(self):
        return None

    def get_constraint_args_keys(self):
        """Returns the args keys of `build_description`."""
        return []

    def check_following(self, value):
        """Checks that the response is in English and in all capital letters."""
        assert isinstance(value, str)

        try:
            return value.isupper() and detect(value, low_memory=False)['lang'] == "en"
        except DetectError as e:
            # Count as Constraint is followed.
            logging.error(
                "Unable to detect language for text %s due to %s", value, e
            )  # refex: disable=pytotw.037
            return True

class EndChecker(Constraint):
    """Checks that the prompt ends with a given phrase."""

    def build_description(self, *, end_phrase=None):
        """Build the Constraint description.

        Args:
          end_phrase: A string representing the phrase the response should end with.

        Returns:
          A string representing the Constraint description.
        """
        self._end_phrase = (
            end_phrase.strip() if isinstance(end_phrase, str) else end_phrase
        )
        if self._end_phrase is None:
            self._end_phrase = random.choice(_ENDING_OPTIONS)
        self._description_pattern = "When reasoning, finish your response with this exact phrase \"{ender}\". No other reasoning words should follow this phrase."
        return self._description_pattern.format(ender=self._end_phrase)

    def get_constraint_args(self):
        return {"end_phrase": self._end_phrase}

    def get_constraint_args_keys(self):
        """Returns the args keys of `build_description`."""
        return ["end_phrase"]

    def check_following(self, value):
        """Checks if the response ends with the expected phrase."""
        value = value.strip().strip('"').lower()
        self._end_phrase = self._end_phrase.strip().lower()
        return value.endswith(self._end_phrase)

class JsonFormat(Constraint):
    """Check the Json format."""

    def build_description(self):
        self._description_pattern = "When reasoning, your response should be wrapped in JSON format. You can use markdown ticks such as ```."
        return self._description_pattern

    def get_constraint_args(self):
        """Returns the keyword args of `build_description`."""
        return None

    def get_constraint_args_keys(self):
        """Returns the args keys of `build_description`."""
        return []

    def check_following(self, value):
        value = (
            value.strip()
            .removeprefix("```json")
            .removeprefix("```Json")
            .removeprefix("```JSON")
            .removeprefix("```")
            .removesuffix("```")
            .strip()
        )
        try:
            json.loads(value)
        except ValueError:
            return False
        return True

class CommaChecker(Constraint):
    """Checks the response for no commas."""

    def build_description(self):
        """Build the Constraint description."""
        self._description_pattern = "When reasoning, refrain from the use of any commas."
        return self._description_pattern

    def get_constraint_args(self):
        return None

    def get_constraint_args_keys(self):
        """Returns the args keys of `build_description`."""
        return []

    def check_following(self, value):
        """Checks that the response does not contain commas."""
        return not re.search(r"\,", value)

